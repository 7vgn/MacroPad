/**
 * \file xmlfile.cpp
 * Implementation for xmlfile.h
 */

#include<stdexcept>
#include<wx/wx.h>
#include<wx/tokenzr.h>
#include<wx/xml/xml.h>
#include"xmlfile.h"

Settings makeEmptySettings()
{
	Settings settings;

	// Set everything to zero
	// All zeros is the default for most attributes: For instance, this makes
	// all macros empty, all pictures black, and all actions "do nothing".
	memset(&settings, 0, sizeof(settings));

	// Set version
	settings.version = VERSION;

	// Some other non-zero entries
	for(int p = 0; p < NUM_PROFILES; p++)
	{
		// Default profile names (to avoid empty strings)
		strcpy(settings.profiles[p].name, wxString("Profile ") << (p + 1));

		// Default longPress 1000ms
		for(unsigned int k = 0; k < sizeof(settings.profiles[p].keys) / sizeof(Key); k++)
			settings.profiles[p].keys[k].longPress = 1000;
	}

	return settings;
}

//-----------------------------------------------------------------------------
// XML parsing

/**
 * \brief Parsing error message
 * \details A description of the last parsing error generated by the xmlTo*()
 * functions.
 */
static wxString parsingError;

/**
 * \brief Find the first child (that is an element node) of an XML element with
 * a given name
 * \param parent The parent element.
 * \param name The name of the child we are looking for.
 * \return Returns a pointer to the child or NULL if none was found.
 */
wxXmlNode* findChild(wxXmlNode* parent, wxString name)
{
	for(wxXmlNode* child = parent->GetChildren(); child; child = child->GetNext())
		if(child->GetType() == wxXML_ELEMENT_NODE && child->GetName() == name)
			return child;
	return NULL;
}

/**
 * \brief Find the first child of an XML element that is of a given type
 * \param parent The parent element.
 * \param type The type of element we are looking for.
 * \return Returns a pointer to the child or NULL if none was found.
 */
wxXmlNode* findChild(wxXmlNode* parent, wxXmlNodeType type)
{
	for(wxXmlNode* child = parent->GetChildren(); child; child = child->GetNext())
		if(child->GetType() == type)
			return child;
	return NULL;
}

/**
 * \brief Convert human-readable string to a monochrome bitmap
 * \param size Size of the image.
 * \param s String consisting of '0's and '1's. Ignores other characters.
 * \param[out] data Pointer to memory that receives the raw bitmap data (1 bit
 * per pixel, left-to-right=lsb-to-msb, each row padded to full byte). Must be
 * large enough to fit the whole bitmap.
 * \return Returns true if the bitmap was successfully read or false if the
 * string cut off prematurely.
 */
bool stringToBitmap(const wxSize& size, wxString s, uint8_t* data)
{
	unsigned int x = 0, y = 0;
	for(unsigned int i = 0; i < s.Length(); i++)
	{
		// Obtain pixel from character if possible
		if(s[i] == '0')
			data[y * ((size.GetWidth() + 7) / 8) + (x / 8)] &= ~(1 << (x % 8));
		else if(s[i] == '1')
			data[y * ((size.GetWidth() + 7) / 8) + (x / 8)] |= 1 << (x % 8);
		else
			continue;
		// Move to next pixel
		x++;
		if(x == size.GetWidth())
		{
			x = 0;
			y++;
			if(y == size.GetHeight())
				break;
		}
	}
	// Check if the whole bitmap has been filled
	return x == 0 && y == size.GetHeight();
}

/**
 * \brief Parse a bitmap from an XML \<image\> element
 * \param xml The XML element to be parsed.
 * \param size The size of the bitmap.
 * \param[out] data The bitmap is parsed into this.
 * \return Returns true if the bitmap was parsed successfully or false if any
 * kind of error occurred. In the latter case, parsingError is set.
 */
bool xmlToBitmap(wxXmlNode* xml, wxSize size, uint8_t* data)
{
	// Must have exactly one child
	if(xml->GetChildren() == NULL || xml->GetChildren()->GetNext() != NULL)
	{
		parsingError = "<image> element does not have exactly one child";
		return false;
	}
	// Child must be text node
	if(xml->GetChildren()->GetType() != wxXML_TEXT_NODE)
	{
		parsingError = "Child of <image> element is not a text node";
		return false;
	}
	// Parse bitmap data
	if(!stringToBitmap(size, xml->GetChildren()->GetContent(), data))
	{
		parsingError = "<image> does not contain sufficient data";
		return false;
	}
	return true;
}

/**
 * \brief Parse an action from an XML \<action\> element
 * \param xml The XML element to be parsed.
 * \param[out] action The action is parsed into this.
 * \return Returns true if the action was parsed successfully or false if any
 * kind of error occurred. In the latter case, parsingError is set.
 */
bool xmlToAction(wxXmlNode* xml, Action& action)
{
	// Attribute "type"
	wxString type = xml->GetAttribute("type");
	if(type == "none")
		action.type = ActionType::NONE;
	else if(type == "switchprofile")
	{
		action.type = ActionType::SWITCH_PROFILE;

		// Attribute "profileid"
		if(!xml->HasAttribute("profileid"))
		{
			parsingError = "<action type=\"switchprofile\"> has not \"profileid\" attribute";
			return false;
		}
		int profileId;
		if(!xml->GetAttribute("profileid").ToInt(&profileId) || profileId <= 0 || profileId > NUM_PROFILES)
		{
			parsingError = "<action type=\"switchprofile\"> has invalid \"profileid\" attribute";
			return false;
		}
		action.switchProfile.index = profileId - 1;
	}
	else if(type == "input")
	{
		action.type = ActionType::INPUT;

		// Go through child elements of <action type="input">
		int keycode = 0;
		for(wxXmlNode* xmlActionChild = xml->GetChildren(); xmlActionChild; xmlActionChild = xmlActionChild->GetNext())
		{
			// Skip anything that isn't an element node
			if(xmlActionChild->GetType() != wxXML_ELEMENT_NODE)
				continue;

			if(xmlActionChild->GetName() == "keycode")
			{
				int keycodeData;
				if(!xmlActionChild->GetNodeContent().ToInt(&keycodeData) || keycodeData < 0 || keycodeData >= 256)
				{
					parsingError = "<keycode>...</keycode> contains invalid data";
					return false;
				}
				if(keycode < MAX_KEYS_PER_ACTION)
					action.input.keys[keycode++] = keycodeData;
			}
			else if(xmlActionChild->GetName() == "modifier")
			{
				if(!xmlActionChild->HasAttribute("type"))
				{
					parsingError = "<modifier> is missing the \"type\" attribute";
					return false;
				}
				wxString modifierType = xmlActionChild->GetAttribute("type");
				if(modifierType == "leftctrl")
					action.input.modifiers |= (1 << 0);
				else if(modifierType == "leftshift")
					action.input.modifiers |= (1 << 1);
				else if(modifierType == "leftalt")
					action.input.modifiers |= (1 << 2);
				else if(modifierType == "leftwindows")
					action.input.modifiers |= (1 << 3);
				else if(modifierType == "rightctrl")
					action.input.modifiers |= (1 << 4);
				else if(modifierType == "rightshift")
					action.input.modifiers |= (1 << 5);
				else if(modifierType == "rightalt")
					action.input.modifiers |= (1 << 6);
				else if(modifierType == "rightwindows")
					action.input.modifiers |= (1 << 7);
				else
				{
					parsingError = "<modifier> has invalid data in \"type\" attribute";
					return false;
				}
			}
			else if(xmlActionChild->GetName() == "mousex")
			{
				int mouse;
				if(!xmlActionChild->GetNodeContent().ToInt(&mouse) || mouse < -127 || mouse > 127)
				{
					parsingError = "<mousex>...</mousex> contains invalid data";
					return false;
				}
				action.input.mouseX = mouse;
			}
			else if(xmlActionChild->GetName() == "mousey")
			{
				int mouse;
				if(!xmlActionChild->GetNodeContent().ToInt(&mouse) || mouse < -127 || mouse > 127)
				{
					parsingError = "<mousey>...</mousey> contains invalid data";
					return false;
				}
				action.input.mouseY = mouse;
			}
			else if(xmlActionChild->GetName() == "mousebutton")
			{
				if(!xmlActionChild->HasAttribute("type"))
				{
					parsingError = "<mousebutton> is missing the \"type\" attribute";
					return false;
				}
				wxString mouseBtnType = xmlActionChild->GetAttribute("type");
				if(mouseBtnType == "left")
					action.input.mouseButtons |= (1 << 0);
				else if(mouseBtnType == "right")
					action.input.mouseButtons |= (1 << 1);
				else if(mouseBtnType == "middle")
					action.input.mouseButtons |= (1 << 2);
				else if(mouseBtnType == "backward")
					action.input.mouseButtons |= (1 << 3);
				else if(mouseBtnType == "forward")
					action.input.mouseButtons |= (1 << 4);
				else
				{
					parsingError = "<mousebutton> has invalid data in \"type\" attribute";
					return false;
				}
			}
			else if(xmlActionChild->GetName() == "mousewheel")
			{
				int mouse;
				if(!xmlActionChild->GetNodeContent().ToInt(&mouse) || mouse < -127 || mouse > 127)
				{
					parsingError = "<mousewheel>...</mousewheel> contains invalid data";
					return false;
				}
				action.input.mouseWheel = mouse;
			}
			else if(xmlActionChild->GetName() == "mousepan")
			{
				int mouse;
				if(!xmlActionChild->GetNodeContent().ToInt(&mouse) || mouse < -127 || mouse > 127)
				{
					parsingError = "<mousepan>...</mousepan> contains invalid data";
					return false;
				}
				action.input.mousePan = mouse;
			}
			else if(xmlActionChild->GetName() == "consumercontrol")
			{
				int consumerCtrl;
				if(!xmlActionChild->GetNodeContent().ToInt(&consumerCtrl) || consumerCtrl < 1 || consumerCtrl > 0x03ff)
				{
					parsingError = "<consumercontrol>...</consumercontrolx> contains invalid data";
					return false;
				}
				action.input.consumerControl = consumerCtrl;
			}
			else if(xmlActionChild->GetName() == "systemcontrol")
			{
				if(!xmlActionChild->HasAttribute("type"))
				{
					parsingError = "<systemcontrol> is missing the \"type\" attribute";
					return false;
				}
				wxString sysCtrlType = xmlActionChild->GetAttribute("type");
				if(sysCtrlType == "powerdown")
					action.input.systemControl = 1;
				else if(sysCtrlType == "sleep")
					action.input.systemControl = 2;
				else if(sysCtrlType == "wakeup")
					action.input.systemControl = 3;
				else
				{
					parsingError = "<systemcontrol> has invalid data in the \"type\" attribute";
					return false;
				}
			}
		}
	}
	else
	{
		parsingError = "<action> element has unknown type attribute";
		return false;
	}
	return true;
}

/**
 * \brief Parse a macro from an XML \<macro\> element
 * \param xml The XML element to be parsed.
 * \param[out] macro The macro is parsed into this.
 * \return Returns true if the macro was parsed successfully or false if any
 * kind of error occurred. In the latter case, parsingError is set.
 */
bool xmlToMacro(wxXmlNode* xml, Macro& macro)
{
	// Go through the children looking for <step> elements
	unsigned int step = 0;
	for(wxXmlNode* xmlStep = xml->GetChildren(); xmlStep && step < MAX_STEPS_PER_MACRO; xmlStep = xmlStep->GetNext())
	{
		// Skip anything that isn't <step>
		if(xmlStep->GetType() != wxXML_ELEMENT_NODE || xmlStep->GetName() != "step")
			continue;

		// Attribute "duration"
		if(!xmlStep->HasAttribute("duration"))
		{
			parsingError = "<step> is missing the \"duration\" attribute";
			return false;
		}
		int duration;
		if(!xmlStep->GetAttribute("duration").ToInt(&duration) || duration < 0)
		{
			parsingError = "<step> has invalid data in the \"duration\" attribute";
			return false;
		}

		// Child element <action>
		wxXmlNode* xmlAction = findChild(xmlStep, "action");
		if(!xmlAction)
		{
			parsingError = "<step> is missing the <action> element";
			return false;
		}
		Action action;
		memset(&action, 0, sizeof(Action));
		if(!xmlToAction(xmlAction, action))
			return false;

		macro.steps[step].action = action;
		macro.steps[step].duration = duration;
		step++;
	}
	macro.numSteps = step;
	return true;
}

Settings loadFromFile(std::string filename)
{
	Settings settings;
	memset(&settings, 0, sizeof(settings));

	// Load file
	wxXmlDocument doc;
	if(!doc.Load(filename))
		throw std::runtime_error("The file \"" + filename + "\" could not be loaded");

	// Root element
	wxXmlNode* xmlRoot = doc.GetRoot();
	if(xmlRoot->GetName() != "macropad")
		throw std::runtime_error("The root element is not <macropad>");
	if(!xmlRoot->HasAttribute("version"))
		throw std::runtime_error("The version attribute is missing in <macropad>");
	wxStringTokenizer versionTokenizer(xmlRoot->GetAttribute("version"), ".");
	unsigned int versionMajor, versionMinor;
	if(!versionTokenizer.HasMoreTokens())
		throw std::runtime_error("The version attribute in <macropad> is invalid");
	versionTokenizer.GetNextToken().ToUInt(&versionMajor);
	if(!versionTokenizer.HasMoreTokens())
		throw std::runtime_error("The version attribute in <macropad> is invalid");
	versionTokenizer.GetNextToken().ToUInt(&versionMinor);
	settings.version = (versionMajor << 8) | versionMinor;
	if(settings.version != VERSION)
		throw std::runtime_error(wxString("This file was generated by a different version (") << (settings.version >> 8) << "." << (settings.version & 0xff) << ") and thus cannot be read by this version (" << (VERSION >> 8) << "." << (VERSION & 0xff) << ")");

	// Profiles
	for(wxXmlNode* xmlProfile = xmlRoot->GetChildren(); xmlProfile; xmlProfile = xmlProfile->GetNext())
	{
		if(xmlProfile->GetName() != "profile")
			continue;

		// Profile id
		if(!xmlProfile->HasAttribute("id"))
			throw std::runtime_error("Found <profile> element without id attribute");
		int profileId;
		if(!xmlProfile->GetAttribute("id").ToInt(&profileId) || profileId <= 0 || profileId > NUM_PROFILES)
			throw std::runtime_error("Invalid profile id");
		Profile& profile = settings.profiles[profileId - 1];

		// Profile name
		strncpy(profile.name, xmlProfile->GetAttribute("name"), MAX_PROFILE_NAME_LEN - 1);

		// Go through the children of the <profile> element
		for(wxXmlNode* xmlProfileChild = xmlProfile->GetChildren(); xmlProfileChild; xmlProfileChild = xmlProfileChild->GetNext())
		{
			if(xmlProfileChild->GetName() == "image")
			{
				if(!xmlToBitmap(xmlProfileChild, wxSize(IMG_PROFILE_WIDTH, IMG_PROFILE_HEIGHT), profile.image))
					throw std::runtime_error("Invalid image data for Profile " + std::to_string(profileId) + ": " + parsingError);
			}
			else if(xmlProfileChild->GetName() == "key")
			{
				// Key id
				if(!xmlProfileChild->HasAttribute("id"))
					throw std::runtime_error("Found <key> element without id attribute in Profile " + std::to_string(profileId));
				int keyId;
				if(!xmlProfileChild->GetAttribute("id").ToInt(&keyId) || keyId <= 0 || keyId > 9)
					throw std::runtime_error("Invalid key id in Profile " + std::to_string(profileId));
				Key& key = profile.keys[keyId - 1];

				// Go through the children of the <key> element
				for(wxXmlNode* xmlKeyChild = xmlProfileChild->GetChildren(); xmlKeyChild; xmlKeyChild = xmlKeyChild->GetNext())
				{
					if(xmlKeyChild->GetName() == "longpress")
					{
						int longPress;
						if
						(
							// Must have exactly one child
							xmlKeyChild->GetChildren() == NULL || xmlKeyChild->GetChildren()->GetNext() != NULL
							// Child must be text node
							|| xmlKeyChild->GetChildren()->GetType() != wxXML_TEXT_NODE
							// Parse integer
							|| !xmlKeyChild->GetChildren()->GetContent().ToInt(&longPress)
							// Verify boundaries
							|| longPress < 0
						)
							throw std::runtime_error("Invalid data in <longpress>...</longpress> for Key " + std::to_string(keyId) + " in Profile " + std::to_string(profileId));
						key.longPress = longPress;
					}
					else if(xmlKeyChild->GetName() == "press")
					{
						wxXmlNode* xmlData = findChild(xmlKeyChild, "macro");
						if(xmlData == NULL)
							throw std::runtime_error("Missing <macro> element in <press>...</press> for Key " + std::to_string(keyId) + " in Profile " + std::to_string(profileId));
						if(!xmlToMacro(xmlData, key.press))
							throw std::runtime_error("Invalid <macro> element in <press>...</press> for Key " + std::to_string(keyId) + " in Profile " + std::to_string(profileId) + ": " + parsingError);
					}
					else if(xmlKeyChild->GetName() == "hold")
					{
						wxXmlNode* xmlData = findChild(xmlKeyChild, "action");
						if(xmlData == NULL)
							throw std::runtime_error("Missing <action> element in <hold>...</hold> for Key " + std::to_string(keyId) + " in Profile " + std::to_string(profileId));
						if(!xmlToAction(xmlData, key.hold))
							throw std::runtime_error("Invalid <action> element in <hold>...</hold> for Key " + std::to_string(keyId) + " in Profile " + std::to_string(profileId) + ": " + parsingError);
					}
					else if(xmlKeyChild->GetName() == "release")
					{
						wxXmlNode* xmlData = findChild(xmlKeyChild, "macro");
						if(xmlData == NULL)
							throw std::runtime_error("Missing <macro> element in <release>...</release> for Key " + std::to_string(keyId) + " in Profile " + std::to_string(profileId));
						if(!xmlToMacro(xmlData, key.release))
							throw std::runtime_error("Invalid <macro> element in <release>...</release> for Key " + std::to_string(keyId) + " in Profile " + std::to_string(profileId) + ": " + parsingError);
					}
					else if(xmlKeyChild->GetName() == "longrelease")
					{
						wxXmlNode* xmlData = findChild(xmlKeyChild, "macro");
						if(xmlData == NULL)
							throw std::runtime_error("Missing <macro> element in <longrelease>...</longrelease> for Key " + std::to_string(keyId) + " in Profile " + std::to_string(profileId));
						if(!xmlToMacro(xmlData, key.longRelease))
							throw std::runtime_error("Invalid <macro> element in <longrelease>...</longrelease> for Key " + std::to_string(keyId) + " in Profile " + std::to_string(profileId) + ": " + parsingError);
					}
					else if(xmlKeyChild->GetName() == "image")
					{
						if(!xmlToBitmap(xmlKeyChild, wxSize(IMG_CTRL_WIDTH, IMG_CTRL_HEIGHT), key.image))
							throw std::runtime_error("Invalid image data for Key " + std::to_string(keyId) + " in Profile " + std::to_string(profileId) + ": " + parsingError);
					}
				}
			}
			else if(xmlProfileChild->GetName() == "knob")
			{
				// Knob id
				if(!xmlProfileChild->HasAttribute("id"))
					throw std::runtime_error("Found <knob> element without id attribute in Profile " + std::to_string(profileId));
				int knobId;
				if(!xmlProfileChild->GetAttribute("id").ToInt(&knobId) || knobId <= 0 || knobId > 3)
					throw std::runtime_error("Invalid knob id in Profile " + std::to_string(profileId));
				Knob& knob = profile.knobs[knobId - 1];

				// Go through the children of the <knob> element
				for(wxXmlNode* xmlKnobChild = xmlProfileChild->GetChildren(); xmlKnobChild; xmlKnobChild = xmlKnobChild->GetNext())
				{
					if(xmlKnobChild->GetName() == "left")
					{
						// Macro
						wxXmlNode* xmlMacro = findChild(xmlKnobChild, "macro");
						if(xmlMacro)
							if(!xmlToMacro(xmlMacro, knob.left))
								throw std::runtime_error("Invalid <macro> element for left turn of Knob " + std::to_string(knobId) + " in Profile " + std::to_string(profileId) + ": " + parsingError);
						// Image
						wxXmlNode* xmlImage = findChild(xmlKnobChild, "image");
						if(xmlImage)
							if(!xmlToBitmap(xmlImage, wxSize(IMG_CTRL_WIDTH, IMG_CTRL_HEIGHT), knob.imageLeft))
								throw std::runtime_error("Invalid image data for left turn of Knob " + std::to_string(knobId) + " in Profile " + std::to_string(profileId) + ": " + parsingError);
					}
					else if(xmlKnobChild->GetName() == "right")
					{
						// Macro
						wxXmlNode* xmlMacro = findChild(xmlKnobChild, "macro");
						if(xmlMacro)
							if(!xmlToMacro(xmlMacro, knob.right))
								throw std::runtime_error("Invalid <macro> element for right turn of Knob " + std::to_string(knobId) + " in Profile " + std::to_string(profileId) + ": " + parsingError);
						// Image
						wxXmlNode* xmlImage = findChild(xmlKnobChild, "image");
						if(xmlImage)
							if(!xmlToBitmap(xmlImage, wxSize(IMG_CTRL_WIDTH, IMG_CTRL_HEIGHT), knob.imageRight))
								throw std::runtime_error("Invalid image data for right turn of Knob " + std::to_string(knobId) + " in Profile " + std::to_string(profileId) + ": " + parsingError);
					}
				}
			}
			else if(xmlProfileChild->GetName() == "slider")
			{
				// Go through the children of the <slider> element
				for(wxXmlNode* xmlSliderChild = xmlProfileChild->GetChildren(); xmlSliderChild; xmlSliderChild = xmlSliderChild->GetNext())
				{
					if(xmlSliderChild->GetName() == "image")
					{
						if(!xmlToBitmap(xmlSliderChild, wxSize(IMG_CTRL_WIDTH, IMG_CTRL_HEIGHT), profile.slider.image))
							throw std::runtime_error("Invalid image data for slider in Profile " + std::to_string(profileId) + ": " + parsingError);
					}
				}
			}
		}
	}

	return settings;
}

//-----------------------------------------------------------------------------
// XML generation

/**
 * \brief Convert a monochrome bitmap to an XML-friendly and somewhat
 * human-readable string
 * \param size Size of the image.
 * \param data Raw bitmap data (1 bit per pixel, left-to-right=lsb-to-msb, each
 * row padded to full byte).
 * \return Returns a string of '0's and '1's with each row on a new line.
 */
wxString bitmapToString(const wxSize& size, const uint8_t* data)
{
	std::string s = "\n";
	for(unsigned int y = 0; y < size.GetHeight(); y++)
	{
		for(unsigned int x = 0; x < size.GetWidth(); x++)
			s += (data[y * ((size.GetWidth() + 7) / 8) + (x / 8)] >> (x % 8)) & 1 ? '1' : '0';
		s += "\n";
	}
	return s;
}

/**
 * \brief Turn an Action into an XML node
 * \param action The action in question.
 * \return Returns a wxXmlNode containing all the information about the action.
 */
wxXmlNode* actionToXml(const Action& action)
{
	wxXmlNode* xmlAction = new wxXmlNode(wxXML_ELEMENT_NODE, "action");
	switch(action.type)
	{
		case ActionType::NONE:
		{
			xmlAction->AddAttribute("type", "none");
			break;
		}
		case ActionType::SWITCH_PROFILE:
		{
			xmlAction->AddAttribute("type", "switchprofile");
			xmlAction->AddAttribute("profileid", wxString() << (action.switchProfile.index + 1));
			break;
		}
		case ActionType::INPUT:
		{
			xmlAction->AddAttribute("type", "input");

			// Keycodes
			for(unsigned int k = 0; k < MAX_KEYS_PER_ACTION; k++)
			{
				if(action.input.keys[k] == 0x00)
					continue;
				wxXmlNode* xmlKeycode = new wxXmlNode(wxXML_ELEMENT_NODE, "keycode");
				xmlAction->AddChild(xmlKeycode);
				wxXmlNode* xmlKeycodeData = new wxXmlNode(xmlKeycode, wxXML_TEXT_NODE, "", wxString() << wxString::Format("%u", action.input.keys[k]));
			}

			// Modifiers
			if(action.input.modifiers & (1 << 0))
				xmlAction->AddChild(new wxXmlNode(NULL, wxXML_ELEMENT_NODE, "modifier", wxEmptyString, new wxXmlAttribute("type", "leftctrl")));
			if(action.input.modifiers & (1 << 1))
				xmlAction->AddChild(new wxXmlNode(NULL, wxXML_ELEMENT_NODE, "modifier", wxEmptyString, new wxXmlAttribute("type", "leftshift")));
			if(action.input.modifiers & (1 << 2))
				xmlAction->AddChild(new wxXmlNode(NULL, wxXML_ELEMENT_NODE, "modifier", wxEmptyString, new wxXmlAttribute("type", "leftalt")));
			if(action.input.modifiers & (1 << 3))
				xmlAction->AddChild(new wxXmlNode(NULL, wxXML_ELEMENT_NODE, "modifier", wxEmptyString, new wxXmlAttribute("type", "leftwindows")));
			if(action.input.modifiers & (1 << 4))
				xmlAction->AddChild(new wxXmlNode(NULL, wxXML_ELEMENT_NODE, "modifier", wxEmptyString, new wxXmlAttribute("type", "rightctrl")));
			if(action.input.modifiers & (1 << 5))
				xmlAction->AddChild(new wxXmlNode(NULL, wxXML_ELEMENT_NODE, "modifier", wxEmptyString, new wxXmlAttribute("type", "rightshift")));
			if(action.input.modifiers & (1 << 6))
				xmlAction->AddChild(new wxXmlNode(NULL, wxXML_ELEMENT_NODE, "modifier", wxEmptyString, new wxXmlAttribute("type", "rightalt")));
			if(action.input.modifiers & (1 << 7))
				xmlAction->AddChild(new wxXmlNode(NULL, wxXML_ELEMENT_NODE, "modifier", wxEmptyString, new wxXmlAttribute("type", "rightwindows")));

			// Mouse x and y
			if(action.input.mouseX != 0)
			{
				wxXmlNode* xmlMouse = new wxXmlNode(wxXML_ELEMENT_NODE, "mousex");
				xmlAction->AddChild(xmlMouse);
				xmlMouse->AddChild(new wxXmlNode(wxXML_TEXT_NODE, "", wxString() << action.input.mouseX));
			}
			if(action.input.mouseY != 0)
			{
				wxXmlNode* xmlMouse = new wxXmlNode(wxXML_ELEMENT_NODE, "mousey");
				xmlAction->AddChild(xmlMouse);
				xmlMouse->AddChild(new wxXmlNode(wxXML_TEXT_NODE, "", wxString() << action.input.mouseY));
			}

			// Mouse buttons
			if(action.input.mouseButtons & (1 << 0))
				xmlAction->AddChild(new wxXmlNode(NULL, wxXML_ELEMENT_NODE, "mousebutton", wxEmptyString, new wxXmlAttribute("type", "left")));
			if(action.input.mouseButtons & (1 << 1))
				xmlAction->AddChild(new wxXmlNode(NULL, wxXML_ELEMENT_NODE, "mousebutton", wxEmptyString, new wxXmlAttribute("type", "right")));
			if(action.input.mouseButtons & (1 << 2))
				xmlAction->AddChild(new wxXmlNode(NULL, wxXML_ELEMENT_NODE, "mousebutton", wxEmptyString, new wxXmlAttribute("type", "middle")));
			if(action.input.mouseButtons & (1 << 3))
				xmlAction->AddChild(new wxXmlNode(NULL, wxXML_ELEMENT_NODE, "mousebutton", wxEmptyString, new wxXmlAttribute("type", "backward")));
			if(action.input.mouseButtons & (1 << 4))
				xmlAction->AddChild(new wxXmlNode(NULL, wxXML_ELEMENT_NODE, "mousebutton", wxEmptyString, new wxXmlAttribute("type", "forward")));

			// Mouse wheel and pan
			if(action.input.mouseWheel != 0)
			{
				wxXmlNode* xmlMouse = new wxXmlNode(wxXML_ELEMENT_NODE, "mousewheel");
				xmlAction->AddChild(xmlMouse);
				xmlMouse->AddChild(new wxXmlNode(wxXML_TEXT_NODE, "", wxString() << action.input.mouseWheel));
			}
			if(action.input.mousePan != 0)
			{
				wxXmlNode* xmlMouse = new wxXmlNode(wxXML_ELEMENT_NODE, "mousepan");
				xmlAction->AddChild(xmlMouse);
				xmlMouse->AddChild(new wxXmlNode(wxXML_TEXT_NODE, "", wxString() << action.input.mousePan));
			}

			// Consumer control
			if(action.input.consumerControl != 0)
			{
				wxXmlNode* xmlConsumerCtrl = new wxXmlNode(wxXML_ELEMENT_NODE, "consumercontrol");
				xmlAction->AddChild(xmlConsumerCtrl);
				xmlConsumerCtrl->AddChild(new wxXmlNode(wxXML_TEXT_NODE, "", wxString() << action.input.consumerControl));
			}

			// System control
			if(action.input.systemControl == 1)
				xmlAction->AddChild(new wxXmlNode(NULL, wxXML_ELEMENT_NODE, "systemcontrol", wxEmptyString, new wxXmlAttribute("type", "powerdown")));
			else if(action.input.systemControl == 2)
				xmlAction->AddChild(new wxXmlNode(NULL, wxXML_ELEMENT_NODE, "systemcontrol", wxEmptyString, new wxXmlAttribute("type", "sleep")));
			else if(action.input.systemControl == 3)
				xmlAction->AddChild(new wxXmlNode(NULL, wxXML_ELEMENT_NODE, "systemcontrol", wxEmptyString, new wxXmlAttribute("type", "wakeup")));

			break;
		}
	}

	return xmlAction;
}

/**
 * \brief Turn a Macro into an XML node
 * \param macro The macro in question.
 * \return Returns a wxXmlNode containing all the information about the macro.
 */
wxXmlNode* macroToXml(const Macro& macro)
{
	wxXmlNode* xmlMacro = new wxXmlNode(wxXML_ELEMENT_NODE, "macro");

	for(unsigned int s = 0; s < macro.numSteps; s++)
	{
		wxXmlNode* xmlStep = new wxXmlNode(wxXML_ELEMENT_NODE, "step");
		xmlMacro->AddChild(xmlStep);
		xmlStep->AddAttribute("duration", wxString() << macro.steps[s].duration);
		xmlStep->AddChild(actionToXml(macro.steps[s].action));
	}

	return xmlMacro;
}

void saveToFile(const Settings& settings, std::string filename)
{
	// Create XML document
	wxXmlDocument doc;

	// Root element
	wxXmlNode* xmlRoot = new wxXmlNode(NULL, wxXML_ELEMENT_NODE, "macropad");
	xmlRoot->AddAttribute("version", wxString::Format("%u.%u", VERSION >> 8, VERSION & 0xff));
	doc.SetRoot(xmlRoot);

	// Profiles
	for(unsigned int p = 0; p < NUM_PROFILES; p++)
	{
		const Profile& profile = settings.profiles[p];
		wxXmlNode* xmlProfile = new wxXmlNode(wxXML_ELEMENT_NODE, "profile");
		xmlRoot->AddChild(xmlProfile);
		xmlProfile->AddAttribute("id", wxString() << (p + 1));

		// Profile name
		xmlProfile->AddAttribute("name", profile.name);

		// Profile picture
		wxXmlNode* xmlProfilePic = new wxXmlNode(wxXML_ELEMENT_NODE, "image");
		xmlProfile->AddChild(xmlProfilePic);
		wxXmlNode* xmlProfilePicData = new wxXmlNode(xmlProfilePic, wxXML_TEXT_NODE, "", bitmapToString(wxSize(IMG_PROFILE_WIDTH, IMG_PROFILE_HEIGHT), profile.image));

		// Keys
		for(unsigned int k = 0; k < sizeof(profile.keys) / sizeof(Key); k++)
		{
			const Key& key = profile.keys[k];
			wxXmlNode* xmlKey = new wxXmlNode(wxXML_ELEMENT_NODE, "key");
			xmlProfile->AddChild(xmlKey);
			xmlKey->AddAttribute("id", wxString() << (k + 1));

			// Long press
			wxXmlNode* xmlKeyLongPress = new wxXmlNode(wxXML_ELEMENT_NODE, "longpress");
			xmlKey->AddChild(xmlKeyLongPress);
			wxXmlNode* xmlKeyLongPressData = new wxXmlNode(xmlKeyLongPress, wxXML_TEXT_NODE, "", wxString() << key.longPress);

			// Macros and actions
			wxXmlNode* xmlKeyPress = new wxXmlNode(wxXML_ELEMENT_NODE, "press");
			xmlKey->AddChild(xmlKeyPress);
			xmlKeyPress->AddChild(macroToXml(key.press));

			wxXmlNode* xmlKeyHold = new wxXmlNode(wxXML_ELEMENT_NODE, "hold");
			xmlKey->AddChild(xmlKeyHold);
			xmlKeyHold->AddChild(actionToXml(key.hold));

			wxXmlNode* xmlKeyRelease = new wxXmlNode(wxXML_ELEMENT_NODE, "release");
			xmlKey->AddChild(xmlKeyRelease);
			xmlKeyRelease->AddChild(macroToXml(key.release));

			wxXmlNode* xmlKeyLongRelease = new wxXmlNode(wxXML_ELEMENT_NODE, "longrelease");
			xmlKey->AddChild(xmlKeyLongRelease);
			xmlKeyLongRelease->AddChild(macroToXml(key.longRelease));

			// Key picture
			wxXmlNode* xmlKeyPic = new wxXmlNode(wxXML_ELEMENT_NODE, "image");
			xmlKey->AddChild(xmlKeyPic);
			wxXmlNode* xmlKeyPicData = new wxXmlNode(xmlKeyPic, wxXML_TEXT_NODE, "", bitmapToString(wxSize(IMG_CTRL_WIDTH, IMG_CTRL_HEIGHT), key.image));
		}

		// Knobs
		for(unsigned int k = 0; k < sizeof(profile.knobs) / sizeof(Knob); k++)
		{
			const Knob& knob = profile.knobs[k];
			wxXmlNode* xmlKnob = new wxXmlNode(wxXML_ELEMENT_NODE, "knob");
			xmlProfile->AddChild(xmlKnob);
			xmlKnob->AddAttribute("id", wxString() << (k + 1));

			// Turn left
			wxXmlNode* xmlKnobLeft = new wxXmlNode(wxXML_ELEMENT_NODE, "left");
			xmlKnob->AddChild(xmlKnobLeft);
			xmlKnobLeft->AddChild(macroToXml(knob.left));

			wxXmlNode* xmlKnobLeftPic = new wxXmlNode(wxXML_ELEMENT_NODE, "image");
			xmlKnobLeft->AddChild(xmlKnobLeftPic);
			wxXmlNode* xmlKnobLeftPicData = new wxXmlNode(xmlKnobLeftPic, wxXML_TEXT_NODE, "", bitmapToString(wxSize(IMG_CTRL_WIDTH, IMG_CTRL_HEIGHT), knob.imageLeft));

			// Turn right
			wxXmlNode* xmlKnobRight = new wxXmlNode(wxXML_ELEMENT_NODE, "right");
			xmlKnob->AddChild(xmlKnobRight);
			xmlKnobRight->AddChild(macroToXml(knob.right));

			wxXmlNode* xmlKnobRightPic = new wxXmlNode(wxXML_ELEMENT_NODE, "image");
			xmlKnobRight->AddChild(xmlKnobRightPic);
			wxXmlNode* xmlKnobRightPicData = new wxXmlNode(xmlKnobRightPic, wxXML_TEXT_NODE, "", bitmapToString(wxSize(IMG_CTRL_WIDTH, IMG_CTRL_HEIGHT), knob.imageRight));
		}

		// Slider
		const Slider& slider = profile.slider;
		wxXmlNode* xmlSlider = new wxXmlNode(wxXML_ELEMENT_NODE, "slider");
		xmlProfile->AddChild(xmlSlider);

		wxXmlNode* xmlSliderPic = new wxXmlNode(wxXML_ELEMENT_NODE, "image");
		xmlSlider->AddChild(xmlSliderPic);
		wxXmlNode* xmlSliderPicData = new wxXmlNode(xmlSliderPic, wxXML_TEXT_NODE, "", bitmapToString(wxSize(IMG_CTRL_WIDTH, IMG_CTRL_HEIGHT), slider.image));
	}

	// Save to file
	if(!doc.Save(filename))
		throw std::runtime_error("The file \"" + filename + "\" could not be written.");
}
